---
const { bookshopData } = Astro.props;

function parseBookshopProperties(bookshopData: any): PropertyMeta[] {
  const properties: PropertyMeta[] = [];

  if (bookshopData.blueprint) {
    Object.entries(bookshopData.blueprint).forEach(([key, value]) => {
      const inputConfig = bookshopData._inputs?.[key];

      properties.push({
        name: key,
        type: getPropertyType(inputConfig),
        optional: false,
        default: formatDefaultValue(value, inputConfig),
        enumValues: getEnumValues(inputConfig),
        description: inputConfig?.comment || "",
        nestedProperties: getNestedProperties(inputConfig),
      });
    });
  }

  return properties;
}

function getPropertyType(inputConfig: any): string {
  if (!inputConfig) {
    return "string";
  }

  switch (inputConfig.type) {
    case "text":
    case "url":
      return "string";
    case "checkbox":
    case "switch":
      return "boolean";
    case "select":
      return "enum";
    case "number":
      return "number";
    case "array":
      return "array";
    case "object":
      return "object";
    default:
      return "string";
  }
}

function formatDefaultValue(value: any, inputConfig: any): string {
  if (value === undefined || value === null) {
    return "";
  }

  // Handle object types
  if (inputConfig?.type === "object" || (typeof value === "object" && !Array.isArray(value))) {
    return "object";
  }

  // Handle arrays
  if (Array.isArray(value)) {
    return value.length > 0 ? `array(${value.length})` : "array";
  }

  // Handle booleans
  if (typeof value === "boolean") {
    return value.toString();
  }

  // Handle other types
  return String(value);
}

function getEnumValues(inputConfig: any): string[] | undefined {
  if (inputConfig?.type === "select" && inputConfig.options?.values) {
    if (Array.isArray(inputConfig.options.values)) {
      // Handle objects with name/value properties
      if (
        inputConfig.options.values.length > 0 &&
        typeof inputConfig.options.values[0] === "object" &&
        inputConfig.options.values[0].hasOwnProperty("value")
      ) {
        return inputConfig.options.values.map((item: any) => item.value);
      }
      // Handle simple string values
      return inputConfig.options.values;
    }
  }
  return undefined;
}

function getNestedProperties(inputConfig: any): PropertyMeta[] | undefined {
  if (inputConfig?.type === "object" && inputConfig._inputs) {
    const nestedProperties: PropertyMeta[] = [];

    Object.entries(inputConfig._inputs).forEach(([key, nestedInput]: [string, any]) => {
      nestedProperties.push({
        name: key,
        type: getPropertyType(nestedInput),
        optional: false,
        default: formatDefaultValue(nestedInput.default, nestedInput),
        enumValues: getEnumValues(nestedInput),
        description: nestedInput?.comment || "",
        nestedProperties: getNestedProperties(nestedInput),
      });
    });

    return nestedProperties;
  }

  return undefined;
}

type PropertyMeta = {
  name: string;
  type: string;
  optional: boolean;
  default: unknown;
  enumValues?: string[];
  description: string;
  nestedProperties?: PropertyMeta[];
};

const properties: PropertyMeta[] = bookshopData ? parseBookshopProperties(bookshopData) : [];
---

<div class="properties">
  {
    properties.length > 0 ? (
      properties.map((prop: PropertyMeta) => {
        function renderProperty(prop: PropertyMeta) {
          return (
            <div class="property">
              <h3>
                {prop.name}{" "}
                <span class="property-type">
                  {prop.type}
                  {prop.default && prop.type !== "object" && ` | default: ${prop.default}`}
                </span>
              </h3>
              {prop.description && <p>{prop.description}</p>}

              {prop.enumValues && prop.enumValues.length > 0 && (
                <div class="enum-values">
                  <strong>Accepted values:</strong>
                  <ul>
                    {prop.enumValues.map((value: string) => (
                      <li>
                        <code>{value}</code>
                      </li>
                    ))}
                  </ul>
                </div>
              )}

              {prop.nestedProperties && prop.nestedProperties.length > 0 && (
                <div class="nested-properties">
                  <strong>Properties:</strong>
                  <div class="nested-property-list">
                    {prop.nestedProperties.map((nestedProp: PropertyMeta) =>
                      renderProperty(nestedProp)
                    )}
                  </div>
                </div>
              )}
            </div>
          );
        }

        return renderProperty(prop);
      })
    ) : (
      <p>No properties available. Make sure the component has a valid bookshop.yml file.</p>
    )
  }
</div>

<style>
  .properties {
    .property {
      border-top: 1px solid var(--border-subtle-borderColor);
      margin-block: var(--spacing-md);

      h3 {
        font-family: var(--font-mono);
        font-size: var(--font-size-md);

        .property-type {
          font-family: var(--font-primary);
          font-size: var(--font-size-sm);
          font-weight: 400;
        }
      }

      .enum-values {
        strong {
          color: var(--text-subtle-textColor);
          display: block;
          font-size: var(--font-size-sm);
          letter-spacing: 0.05em;
          text-transform: uppercase;
        }

        ul {
          display: flex;
          flex-wrap: wrap;
          gap: var(--space-md);
          list-style: none;
          margin: 0;
          padding: 0;
        }

        li {
          code {
            background: var(--background-subtle-backgroundColor);
            font-size: var(--font-size-sm);
            padding: 0;
          }
        }
      }
    }
  }

  .nested-property-list {
    border: 1px solid var(--border-subtle-borderColor);
    border-radius: var(--radius-xs);
    margin-top: var(--spacing-md);
    padding-inline: var(--spacing-md);

    .property:first-child {
      border-top: none;
    }
  }
</style>
